"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disableTypeChecks = void 0;
const core_1 = require("@stryker-mutator/api/core");
const util_1 = require("@stryker-mutator/util");
const parsers_1 = require("./parsers");
const syntax_1 = require("./syntax");
const commentDirectiveRegEx = /^(\s*)@(ts-[a-z-]+).*$/;
const tsDirectiveLikeRegEx = /@(ts-[a-z-]+)/;
const startingCommentRegex = /(^\s*\/\*.*?\*\/)/gs;
async function disableTypeChecks(file, options) {
    if (isJSFileWithoutTSDirectives(file)) {
        // Performance optimization. Only parse the file when it has a change of containing a `// @ts-` directive
        return new core_1.File(file.name, prefixWithNoCheck(file.textContent));
    }
    const parse = parsers_1.createParser(options);
    const ast = await parse(file.textContent, file.name);
    switch (ast.format) {
        case syntax_1.AstFormat.JS:
        case syntax_1.AstFormat.TS:
            return new core_1.File(file.name, disableTypeCheckingInBabelAst(ast));
        case syntax_1.AstFormat.Html:
            return new core_1.File(file.name, disableTypeCheckingInHtml(ast));
    }
}
exports.disableTypeChecks = disableTypeChecks;
function isJSFileWithoutTSDirectives(file) {
    const format = parsers_1.getFormat(file.name);
    return (format === syntax_1.AstFormat.TS || format === syntax_1.AstFormat.JS) && !tsDirectiveLikeRegEx.test(file.textContent);
}
function disableTypeCheckingInBabelAst(ast) {
    return prefixWithNoCheck(removeTSDirectives(ast.rawContent, ast.root.comments));
}
function prefixWithNoCheck(code) {
    var _a, _b;
    if (code.startsWith('#')) {
        // first line has a shebang (#!/usr/bin/env node)
        const newLineIndex = code.indexOf('\n');
        if (newLineIndex > 0) {
            return `${code.substr(0, newLineIndex)}\n// @ts-nocheck\n${code.substr(newLineIndex + 1)}`;
        }
        else {
            return code;
        }
    }
    else {
        // We should leave comments, like `/** @jest-env jsdom */ at the top of the file, see #2569
        const commentMatch = startingCommentRegex.exec(code);
        return `${(_a = commentMatch === null || commentMatch === void 0 ? void 0 : commentMatch[1].concat('\n')) !== null && _a !== void 0 ? _a : ''}// @ts-nocheck\n${code.substr((_b = commentMatch === null || commentMatch === void 0 ? void 0 : commentMatch[1].length) !== null && _b !== void 0 ? _b : 0)}`;
    }
}
function disableTypeCheckingInHtml(ast) {
    const sortedScripts = [...ast.root.scripts].sort((a, b) => a.root.start - b.root.start);
    let currentIndex = 0;
    let html = '';
    for (const script of sortedScripts) {
        html += ast.rawContent.substring(currentIndex, script.root.start);
        html += '\n';
        html += prefixWithNoCheck(removeTSDirectives(script.rawContent, script.root.comments));
        html += '\n';
        currentIndex = script.root.end;
    }
    html += ast.rawContent.substr(currentIndex);
    return html;
}
function removeTSDirectives(text, comments) {
    const directiveRanges = comments === null || comments === void 0 ? void 0 : comments.map(tryParseTSDirective).filter(util_1.notEmpty).sort((a, b) => a[0] - b[0]);
    if (directiveRanges) {
        let currentIndex = 0;
        let pruned = '';
        for (const directiveRange of directiveRanges) {
            pruned += text.substring(currentIndex, directiveRange[0]);
            currentIndex = directiveRange[1];
        }
        pruned += text.substr(currentIndex);
        return pruned;
    }
    else {
        return text;
    }
}
function tryParseTSDirective(comment) {
    const match = commentDirectiveRegEx.exec(comment.value);
    if (match) {
        const directiveStartPos = comment.start + match[1].length + 2; // +2 to account for the `//` or `/*` start character
        return [directiveStartPos, directiveStartPos + match[2].length + 1];
    }
    return undefined;
}
//# sourceMappingURL=disable-type-checks.js.map