"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instrumenter = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const plugin_1 = require("@stryker-mutator/api/plugin");
const core_1 = require("@stryker-mutator/api/core");
const parsers_1 = require("./parsers");
const transformers_1 = require("./transformers");
const printers_1 = require("./printers");
/**
 * The instrumenter is responsible for
 * * Generating mutants based on source files
 * * Instrumenting the source code with the mutants placed in `mutant switches`.
 * * Adding mutant coverage expressions in the source code.
 * @see https://github.com/stryker-mutator/stryker/issues/1514
 */
class Instrumenter {
    constructor(logger) {
        this.logger = logger;
    }
    async instrument(files, options) {
        var e_1, _a;
        this.logger.debug('Instrumenting %d source files with mutants', files.length);
        const mutantCollector = new transformers_1.MutantCollector();
        const outFiles = [];
        let mutantCount = 0;
        const parse = parsers_1.createParser(options);
        try {
            for (var files_1 = tslib_1.__asyncValues(files), files_1_1; files_1_1 = await files_1.next(), !files_1_1.done;) {
                const file = files_1_1.value;
                const ast = await parse(file.textContent, file.name);
                transformers_1.transform(ast, mutantCollector, { options });
                const mutatedContent = printers_1.print(ast);
                outFiles.push(new core_1.File(file.name, mutatedContent));
                if (this.logger.isDebugEnabled()) {
                    const nrOfMutantsInFile = mutantCollector.mutants.length - mutantCount;
                    mutantCount = mutantCollector.mutants.length;
                    this.logger.debug(`Instrumented ${path_1.default.relative(process.cwd(), file.name)} (${nrOfMutantsInFile} mutant(s))`);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (files_1_1 && !files_1_1.done && (_a = files_1.return)) await _a.call(files_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const mutants = mutantCollector.mutants.map((mutant) => mutant.toApiMutant());
        this.logger.info('Instrumented %d source file(s) with %d mutant(s)', files.length, mutants.length);
        return {
            files: outFiles,
            mutants,
        };
    }
}
exports.Instrumenter = Instrumenter;
Instrumenter.inject = plugin_1.tokens(plugin_1.commonTokens.logger);
//# sourceMappingURL=instrumenter.js.map