"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressionMutantPlacer = void 0;
const core_1 = require("@babel/core");
const syntax_helpers_1 = require("../util/syntax-helpers");
function nameAnonymousClassOrFunctionExpression(path) {
    var _a;
    if ((path.isFunctionExpression() || path.isClassExpression()) && !path.node.id) {
        if (path.parentPath.isVariableDeclarator() && core_1.types.isIdentifier(path.parentPath.node.id)) {
            path.node.id = path.parentPath.node.id;
        }
        else if (path.parentPath.isObjectProperty() &&
            core_1.types.isIdentifier(path.parentPath.node.key) && ((_a = path.getStatementParent()) === null || _a === void 0 ? void 0 : _a.isVariableDeclaration())) {
            path.node.id = path.parentPath.node.key;
        }
    }
}
function nameIfAnonymous(path) {
    nameAnonymousClassOrFunctionExpression(path);
    if (path.isArrowFunctionExpression() && path.parentPath.isVariableDeclarator() && core_1.types.isIdentifier(path.parentPath.node.id)) {
        path.replaceWith(core_1.types.callExpression(core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([
            core_1.types.variableDeclaration('const', [core_1.types.variableDeclarator(path.parentPath.node.id, path.node)]),
            core_1.types.returnStatement(path.parentPath.node.id),
        ])), []));
    }
    return path;
}
function isValidParent(child) {
    const parent = child.parentPath;
    return !isObjectPropertyKey() && !parent.isTaggedTemplateExpression();
    function isObjectPropertyKey() {
        return parent.isObjectProperty() && parent.node.key === child.node;
    }
}
/**
 * Places the mutants with a conditional expression: `global.activeMutant === 1? mutatedCode : regularCode`;
 */
const expressionMutantPlacer = (path, mutants) => {
    if (path.isExpression() && isValidParent(path)) {
        // First calculated the mutated ast before we start to apply mutants.
        const appliedMutants = mutants.map((mutant) => ({
            mutant,
            ast: syntax_helpers_1.createMutatedAst(path, mutant),
        }));
        // Make sure anonymous functions and classes keep their 'name' property
        path.replaceWith(nameIfAnonymous(path));
        // Add the mutation coverage expression
        path.replaceWith(syntax_helpers_1.mutationCoverageSequenceExpression(mutants, path.node));
        // Now apply the mutants
        for (const appliedMutant of appliedMutants) {
            path.replaceWith(core_1.types.conditionalExpression(syntax_helpers_1.mutantTestExpression(appliedMutant.mutant.id), appliedMutant.ast, path.node));
        }
        return true;
    }
    else {
        return false;
    }
};
exports.expressionMutantPlacer = expressionMutantPlacer;
//# sourceMappingURL=expression-mutant-placer.js.map