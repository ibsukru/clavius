"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionalExpressionMutator = void 0;
const core_1 = require("@babel/core");
class ConditionalExpressionMutator {
    constructor() {
        this.validOperators = ['!=', '!==', '&&', '<', '<=', '==', '===', '>', '>=', '||'];
        this.name = 'ConditionalExpression';
    }
    hasValidParent(node) {
        return !(core_1.types.isForStatement(node.parent) ||
            core_1.types.isWhileStatement(node.parent) ||
            core_1.types.isIfStatement(node.parent) ||
            core_1.types.isDoWhileStatement(node.parent));
    }
    isValidOperator(operator) {
        return this.validOperators.includes(operator);
    }
    mutate(path) {
        if ((path.isBinaryExpression() || path.isLogicalExpression()) && this.hasValidParent(path) && this.isValidOperator(path.node.operator)) {
            return [
                { original: path.node, replacement: core_1.types.booleanLiteral(true) },
                { original: path.node, replacement: core_1.types.booleanLiteral(false) },
            ];
        }
        if (path.isDoWhileStatement() || path.isWhileStatement()) {
            return [{ original: path.node.test, replacement: core_1.types.booleanLiteral(false) }];
        }
        if (path.isForStatement()) {
            if (!path.node.test) {
                const replacement = core_1.types.cloneNode(path.node, /* deep */ false);
                replacement.test = core_1.types.booleanLiteral(false);
                return [{ original: path.node, replacement }];
            }
            return [{ original: path.node.test, replacement: core_1.types.booleanLiteral(false) }];
        }
        if (path.isIfStatement()) {
            return [
                // raw string mutations in the `if` condition
                { original: path.node.test, replacement: core_1.types.booleanLiteral(true) },
                { original: path.node.test, replacement: core_1.types.booleanLiteral(false) },
            ];
        }
        if (path.isSwitchCase() &&
            // if not a fallthrough case
            path.node.consequent.length > 0) {
            const replacement = core_1.types.cloneNode(path.node);
            replacement.consequent = [];
            return [{ original: path.node, replacement }];
        }
        return [];
    }
}
exports.ConditionalExpressionMutator = ConditionalExpressionMutator;
//# sourceMappingURL=conditional-expression-mutator.js.map