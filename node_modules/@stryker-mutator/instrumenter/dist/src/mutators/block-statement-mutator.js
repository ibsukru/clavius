"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockStatementMutator = void 0;
const core_1 = require("@babel/core");
class BlockStatementMutator {
    constructor() {
        this.name = 'BlockStatement';
    }
    mutate(path) {
        if (path.isBlockStatement() && this.isValid(path)) {
            const replacement = core_1.types.cloneNode(path.node, false);
            replacement.body = [];
            return [{ original: path.node, replacement }];
        }
        else {
            return [];
        }
    }
    isValid(path) {
        return !this.isEmpty(path) && !this.isInvalidConstructorBody(path);
    }
    isEmpty(path) {
        return !path.node.body.length;
    }
    /**
     * Checks to see if a statement is an invalid constructor body
     * @example
     * // Invalid!
     * class Foo extends Bar {
     *   constructor(public baz: string) {
     *     super(42);
     *   }
     * }
     * @example
     * // Invalid!
     * class Foo extends Bar {
     *   public baz = 'string';
     *   constructor() {
     *     super(42);
     *   }
     * }
     * @see https://github.com/stryker-mutator/stryker/issues/2314
     * @see https://github.com/stryker-mutator/stryker/issues/2474
     */
    isInvalidConstructorBody(blockStatement) {
        return !!(blockStatement.parentPath.isClassMethod() &&
            blockStatement.parentPath.node.kind === 'constructor' &&
            (this.containsTSParameterProperties(blockStatement.parentPath) || this.containsInitializedClassProperties(blockStatement.parentPath)) &&
            this.hasSuperExpressionOnFirstLine(blockStatement));
    }
    containsTSParameterProperties(constructor) {
        return constructor.node.params.some((param) => core_1.types.isTSParameterProperty(param));
    }
    containsInitializedClassProperties(constructor) {
        return (constructor.parentPath.isClassBody() &&
            constructor.parentPath.node.body.some((classMember) => core_1.types.isClassProperty(classMember) && classMember.value));
    }
    hasSuperExpressionOnFirstLine(constructor) {
        return (core_1.types.isExpressionStatement(constructor.node.body[0]) &&
            core_1.types.isCallExpression(constructor.node.body[0].expression) &&
            core_1.types.isSuper(constructor.node.body[0].expression.callee));
    }
}
exports.BlockStatementMutator = BlockStatementMutator;
//# sourceMappingURL=block-statement-mutator.js.map