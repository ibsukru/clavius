"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mutate = exports.mutators = void 0;
const tslib_1 = require("tslib");
const util_1 = require("@stryker-mutator/util");
const arithmetic_operator_mutator_1 = require("./arithmetic-operator-mutator");
const block_statement_mutator_1 = require("./block-statement-mutator");
const conditional_expression_mutator_1 = require("./conditional-expression-mutator");
const string_literal_mutator_1 = require("./string-literal-mutator");
const array_declaration_mutator_1 = require("./array-declaration-mutator");
const arrow_function_mutator_1 = require("./arrow-function-mutator");
const boolean_literal_mutator_1 = require("./boolean-literal-mutator");
const equality_operator_mutator_1 = require("./equality-operator-mutator");
const logical_operator_mutator_1 = require("./logical-operator-mutator");
const object_literal_mutator_1 = require("./object-literal-mutator");
const unary_operator_mutator_1 = require("./unary-operator-mutator");
const update_operator_mutator_1 = require("./update-operator-mutator");
tslib_1.__exportStar(require("./node-mutator"), exports);
tslib_1.__exportStar(require("./mutator-options"), exports);
exports.mutators = [
    new arithmetic_operator_mutator_1.ArithmeticOperatorMutator(),
    new array_declaration_mutator_1.ArrayDeclarationMutator(),
    new arrow_function_mutator_1.ArrowFunctionMutator(),
    new block_statement_mutator_1.BlockStatementMutator(),
    new boolean_literal_mutator_1.BooleanLiteralMutator(),
    new conditional_expression_mutator_1.ConditionalExpressionMutator(),
    new equality_operator_mutator_1.EqualityOperatorMutator(),
    new logical_operator_mutator_1.LogicalOperatorMutator(),
    new object_literal_mutator_1.ObjectLiteralMutator(),
    new string_literal_mutator_1.StringLiteralMutator(),
    new unary_operator_mutator_1.UnaryOperatorMutator(),
    new update_operator_mutator_1.UpdateOperatorMutator(),
];
exports.mutate = (node, { excludedMutations }) => {
    return util_1.flatMap(exports.mutators, (mutator) => mutator.mutate(node).map((nodeMutation) => (Object.assign(Object.assign({}, nodeMutation), { mutatorName: mutator.name, ignoreReason: formatIgnoreReason(mutator.name) }))));
    function formatIgnoreReason(mutatorName) {
        if (excludedMutations.includes(mutatorName)) {
            return `Ignored because of excluded mutation "${mutatorName}"`;
        }
        else {
            return undefined;
        }
    }
};
//# sourceMappingURL=index.js.map