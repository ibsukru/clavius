"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringLiteralMutator = void 0;
const core_1 = require("@babel/core");
class StringLiteralMutator {
    constructor() {
        this.name = 'StringLiteral';
    }
    mutate(path) {
        if (path.isTemplateLiteral()) {
            const replacement = path.node.quasis.length === 1 && path.node.quasis[0].value.raw.length === 0 ? 'Stryker was here!' : '';
            return [
                {
                    original: path.node,
                    replacement: core_1.types.templateLiteral([core_1.types.templateElement({ raw: replacement })], []),
                },
            ];
        }
        if (path.isStringLiteral() && this.isValidParent(path)) {
            return [
                {
                    original: path.node,
                    replacement: core_1.types.stringLiteral(path.node.value.length === 0 ? 'Stryker was here!' : ''),
                },
            ];
        }
        return [];
    }
    isValidParent(child) {
        const parent = child.parent;
        return !(core_1.types.isImportDeclaration(parent) ||
            core_1.types.isExportDeclaration(parent) ||
            core_1.types.isModuleDeclaration(parent) ||
            core_1.types.isTSExternalModuleReference(parent) ||
            core_1.types.isJSXAttribute(parent) ||
            core_1.types.isExpressionStatement(parent) ||
            core_1.types.isTSLiteralType(parent) ||
            (core_1.types.isObjectProperty(parent) && parent.key === child.node) ||
            (core_1.types.isClassProperty(parent) && parent.key === child.node) ||
            (core_1.types.isCallExpression(parent) && core_1.types.isIdentifier(parent.callee, { name: 'require' })));
    }
}
exports.StringLiteralMutator = StringLiteralMutator;
//# sourceMappingURL=string-literal-mutator.js.map