"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const log4js_1 = require("log4js");
const util_1 = require("@stryker-mutator/util");
const test_runner_decorator_1 = require("./test-runner-decorator");
/**
 * Wraps a test runner and implements the timeout functionality.
 */
class TimeoutDecorator extends test_runner_decorator_1.default {
    constructor() {
        super(...arguments);
        this.log = log4js_1.getLogger(TimeoutDecorator.name);
    }
    async dryRun(options) {
        const result = await this.run(options, () => super.dryRun(options));
        if (result === util_1.ExpirableTask.TimeoutExpired) {
            return {
                status: test_runner_1.DryRunStatus.Timeout,
            };
        }
        else {
            return result;
        }
    }
    async mutantRun(options) {
        const result = await this.run(options, () => super.mutantRun(options));
        if (result === util_1.ExpirableTask.TimeoutExpired) {
            return {
                status: test_runner_1.MutantRunStatus.Timeout,
            };
        }
        else {
            return result;
        }
    }
    async run(options, actRun) {
        this.log.debug('Starting timeout timer (%s ms) for a test run', options.timeout);
        const result = await util_1.ExpirableTask.timeout(actRun(), options.timeout);
        if (result === util_1.ExpirableTask.TimeoutExpired) {
            await this.handleTimeout();
            return result;
        }
        else {
            return result;
        }
    }
    async handleTimeout() {
        this.log.debug('Timeout expired, restarting the process and reporting timeout');
        await this.dispose();
        this.createInnerRunner();
        await this.init();
    }
}
exports.default = TimeoutDecorator;
//# sourceMappingURL=timeout-decorator.js.map