"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const os = require("os");
const core_1 = require("@stryker-mutator/api/core");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
const object_utils_1 = require("../utils/object-utils");
const timer_1 = require("../utils/timer");
/**
 * A test runner that uses a (bash or cmd) command to execute the tests.
 * Does not know hom many tests are executed or any code coverage results,
 * instead, it mimics a simple test result based on the exit code.
 * The command can be configured, but defaults to `npm test`.
 */
class CommandTestRunner {
    constructor(workingDir, options) {
        this.workingDir = workingDir;
        this.settings = options.commandRunner;
    }
    /**
     * Determines whether a given name is "command" (ignore case)
     * @param name Maybe "command", maybe not
     */
    static is(name) {
        return this.runnerName === name.toLowerCase();
    }
    async dryRun({ coverageAnalysis }) {
        if (coverageAnalysis !== 'off') {
            throw new util_1.StrykerError(`The "${CommandTestRunner.runnerName}" test runner does not support coverageAnalysis "${coverageAnalysis}". Please set "coverageAnalysis": "off".`);
        }
        return this.run({});
    }
    async mutantRun({ activeMutant }) {
        const result = await this.run({ activeMutantId: activeMutant.id });
        return test_runner_1.toMutantRunResult(result);
    }
    run({ activeMutantId }) {
        return new Promise((res, rej) => {
            const timer = new timer_1.default();
            const output = [];
            const env = activeMutantId === undefined
                ? process.env
                : Object.assign(Object.assign({}, process.env), { [core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT_ENV_VARIABLE]: activeMutantId.toString() });
            const childProcess = child_process_1.exec(this.settings.command, { cwd: this.workingDir, env });
            childProcess.on('error', (error) => {
                object_utils_1.kill(childProcess.pid)
                    .then(() => handleResolve(errorResult(error)))
                    .catch(rej);
            });
            childProcess.on('exit', (code) => {
                const result = completeResult(code, timer);
                handleResolve(result);
            });
            childProcess.stdout.on('data', (chunk) => {
                output.push(chunk);
            });
            childProcess.stderr.on('data', (chunk) => {
                output.push(chunk);
            });
            this.timeoutHandler = async () => {
                handleResolve({ status: test_runner_1.DryRunStatus.Timeout });
                await object_utils_1.kill(childProcess.pid);
            };
            const handleResolve = (runResult) => {
                removeAllListeners();
                this.timeoutHandler = undefined;
                res(runResult);
            };
            function removeAllListeners() {
                childProcess.stderr.removeAllListeners();
                childProcess.stdout.removeAllListeners();
                childProcess.removeAllListeners();
            }
            function errorResult(error) {
                return {
                    errorMessage: util_1.errorToString(error),
                    status: test_runner_1.DryRunStatus.Error,
                };
            }
            function completeResult(exitCode, timer) {
                const duration = timer.elapsedMs();
                if (exitCode === 0) {
                    return {
                        status: test_runner_1.DryRunStatus.Complete,
                        tests: [
                            {
                                id: 'all',
                                name: 'All tests',
                                status: test_runner_1.TestStatus.Success,
                                timeSpentMs: duration,
                            },
                        ],
                    };
                }
                else {
                    return {
                        status: test_runner_1.DryRunStatus.Complete,
                        tests: [
                            {
                                id: 'all',
                                failureMessage: output.map((buf) => buf.toString()).join(os.EOL),
                                name: 'All tests',
                                status: test_runner_1.TestStatus.Failed,
                                timeSpentMs: duration,
                            },
                        ],
                    };
                }
            }
        });
    }
    async dispose() {
        if (this.timeoutHandler) {
            await this.timeoutHandler();
        }
    }
}
exports.default = CommandTestRunner;
/**
 * "command"
 */
CommandTestRunner.runnerName = CommandTestRunner.name.replace('TestRunner', '').toLowerCase();
//# sourceMappingURL=command-test-runner.js.map