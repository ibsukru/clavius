"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChildProcessTestRunnerWorker = void 0;
const plugin_1 = require("@stryker-mutator/api/plugin");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
class ChildProcessTestRunnerWorker {
    constructor({ testRunner }, injector) {
        this.underlyingTestRunner = injector.injectFunction(di_1.PluginCreator.createFactory(plugin_1.PluginKind.TestRunner)).create(testRunner);
    }
    async init() {
        if (this.underlyingTestRunner.init) {
            await this.underlyingTestRunner.init();
        }
    }
    async dispose() {
        if (this.underlyingTestRunner.dispose) {
            await this.underlyingTestRunner.dispose();
        }
    }
    async dryRun(options) {
        const dryRunResult = await this.underlyingTestRunner.dryRun(options);
        if (dryRunResult.status === test_runner_1.DryRunStatus.Complete && !dryRunResult.mutantCoverage && options.coverageAnalysis !== 'off') {
            // @ts-expect-error
            dryRunResult.mutantCoverage = global.__mutantCoverage__;
        }
        if (dryRunResult.status === test_runner_1.DryRunStatus.Error) {
            dryRunResult.errorMessage = util_1.errorToString(dryRunResult.errorMessage);
        }
        return dryRunResult;
    }
    async mutantRun(options) {
        const result = await this.underlyingTestRunner.mutantRun(options);
        if (result.status === test_runner_1.MutantRunStatus.Error) {
            result.errorMessage = util_1.errorToString(result.errorMessage);
        }
        return result;
    }
}
exports.ChildProcessTestRunnerWorker = ChildProcessTestRunnerWorker;
ChildProcessTestRunnerWorker.inject = plugin_1.tokens(plugin_1.commonTokens.options, plugin_1.commonTokens.injector);
//# sourceMappingURL=child-process-test-runner-worker.js.map