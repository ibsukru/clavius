"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const out_of_memory_error_1 = require("../child-proxy/out-of-memory-error");
const test_runner_decorator_1 = require("./test-runner-decorator");
const ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';
/**
 * Wraps a test runner and implements the retry functionality.
 */
class RetryDecorator extends test_runner_decorator_1.default {
    constructor() {
        super(...arguments);
        this.log = log4js_1.getLogger(RetryDecorator.name);
    }
    async dryRun(options) {
        const result = await this.run(() => super.dryRun(options));
        if (typeof result === 'string') {
            return {
                status: test_runner_1.DryRunStatus.Error,
                errorMessage: result,
            };
        }
        else {
            return result;
        }
    }
    async mutantRun(options) {
        const result = await this.run(() => super.mutantRun(options));
        if (typeof result === 'string') {
            return {
                status: test_runner_1.MutantRunStatus.Error,
                errorMessage: result,
            };
        }
        else {
            return result;
        }
    }
    async run(actRun, attemptsLeft = 2, lastError) {
        if (attemptsLeft > 0) {
            try {
                return await actRun();
            }
            catch (error) {
                if (error instanceof out_of_memory_error_1.default) {
                    this.log.info("Test runner process [%s] ran out of memory. You probably have a memory leak in your tests. Don't worry, Stryker will restart the process, but you might want to investigate this later, because this decreases performance.", error.pid);
                }
                await this.recover();
                return this.run(actRun, attemptsLeft - 1, error);
            }
        }
        else {
            await this.recover();
            return `${ERROR_MESSAGE}${util_1.errorToString(lastError)}`;
        }
    }
    async recover() {
        await this.dispose();
        this.createInnerRunner();
        return this.init();
    }
}
exports.default = RetryDecorator;
//# sourceMappingURL=retry-decorator.js.map