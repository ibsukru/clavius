"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const string_decoder_1 = require("string_decoder");
const path = require("path");
const fs = require("fs");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const file_utils_1 = require("../utils/file-utils");
const options_validator_1 = require("../config/options-validator");
const input_file_collection_1 = require("./input-file-collection");
function toReportSourceFile(file) {
    return {
        content: file.textContent,
        path: file.name,
    };
}
const IGNORE_PATTERN_CHARACTER = '!';
/**
 *  When characters are represented as the octal values of its utf8 encoding
 *  e.g. Ã¥ becomes \303\245 in git.exe output
 */
function decodeGitLsOutput(line) {
    if (line.startsWith('"') && line.endsWith('"')) {
        return line
            .substr(1, line.length - 2)
            .replace(/\\\\/g, '\\')
            .replace(/(?:\\\d+)*/g, (octalEscapeSequence) => new string_decoder_1.StringDecoder('utf-8').write(Buffer.from(octalEscapeSequence
            .split('\\')
            .filter(Boolean)
            .map((octal) => parseInt(octal, 8)))));
    }
    return line;
}
class InputFileResolver {
    constructor(log, { mutate, files, tempDirName }, reporter) {
        this.log = log;
        this.reporter = reporter;
        this.tempDirName = tempDirName;
        this.mutatePatterns = mutate;
        if (files) {
            this.filePatterns = files;
        }
    }
    async resolve() {
        const [inputFileNames, mutateFiles] = await Promise.all([this.resolveInputFiles(), this.resolveMutateFiles()]);
        const files = await this.readFiles(inputFileNames);
        const inputFileCollection = new input_file_collection_1.default(files, mutateFiles);
        this.reportAllSourceFilesRead(files);
        inputFileCollection.logFiles(this.log);
        return inputFileCollection;
    }
    resolveInputFiles() {
        if (this.filePatterns) {
            return this.expand(this.filePatterns);
        }
        else {
            return this.resolveFilesUsingGit();
        }
    }
    resolveMutateFiles() {
        return this.expand(this.mutatePatterns, !shallowEquals(this.mutatePatterns, options_validator_1.defaultOptions().mutate));
        function shallowEquals(arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            else {
                for (let i = 0; i < arr1.length; i++) {
                    if (arr1[i] !== arr2[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    /**
     * Takes a list of globbing patterns and expands them into files.
     * If a patterns starts with a `!`, it negates the pattern.
     * @param patterns The patterns to expand into files
     */
    async expand(patterns, logAboutUselessPatterns = true) {
        const fileSet = new Set();
        for (const pattern of patterns) {
            if (pattern.startsWith(IGNORE_PATTERN_CHARACTER)) {
                const files = await this.expandPattern(pattern.substr(1), logAboutUselessPatterns);
                files.forEach((fileName) => fileSet.delete(fileName));
            }
            else {
                const files = await this.expandPattern(pattern, logAboutUselessPatterns);
                files.forEach((fileName) => fileSet.add(fileName));
            }
        }
        return Array.from(fileSet);
    }
    async expandPattern(globbingExpression, logAboutUselessPatterns) {
        const fileNames = (await file_utils_1.glob(globbingExpression)).map((relativeFile) => path.resolve(relativeFile));
        if (!fileNames.length && logAboutUselessPatterns) {
            this.log.warn(`Globbing expression "${globbingExpression}" did not result in any files.`);
        }
        return fileNames;
    }
    async resolveFilesUsingGit() {
        try {
            const { stdout } = await util_1.childProcessAsPromised.exec(`git ls-files --others --exclude-standard --cached --exclude /${this.tempDirName}/*`, {
                maxBuffer: 10 * 1000 * 1024,
            });
            const relativeFileNames = stdout
                .toString()
                .split('\n')
                .map((line) => line.trim())
                .filter(Boolean) // remove empty lines
                .map(decodeGitLsOutput);
            const fileNames = relativeFileNames.map((relativeFileName) => path.resolve(relativeFileName));
            return fileNames;
        }
        catch (error) {
            throw new util_1.StrykerError(util_1.normalizeWhitespaces(`Cannot determine input files. Either specify a \`files\`
        array in your stryker configuration, or make sure "${process.cwd()}"
        is located inside a git repository`), error);
        }
    }
    reportAllSourceFilesRead(allFiles) {
        this.reporter.onAllSourceFilesRead(allFiles.map(toReportSourceFile));
    }
    reportSourceFilesRead(textFile) {
        this.reporter.onSourceFileRead(toReportSourceFile(textFile));
    }
    async readFiles(fileNames) {
        const files = rxjs_1.from(fileNames)
            .pipe(operators_1.mergeMap((fileName) => this.readFile(fileName), file_utils_1.MAX_CONCURRENT_FILE_IO), operators_1.filter(util_1.notEmpty), operators_1.toArray(), 
        // Filter the files here, so we force a deterministic instrumentation process
        operators_1.map((files) => files.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))))
            .toPromise();
        return files;
    }
    async readFile(fileName) {
        try {
            const content = await fs.promises.readFile(fileName);
            const file = new core_1.File(fileName, content);
            this.reportSourceFilesRead(file);
            return file;
        }
        catch (error) {
            if ((util_1.isErrnoException(error) && error.code === 'ENOENT') || error.code === 'EISDIR') {
                return null; // file is deleted or a directory. This can be a valid result of the git command
            }
            else {
                // Rethrow
                throw error;
            }
        }
    }
}
exports.default = InputFileResolver;
InputFileResolver.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.reporter);
//# sourceMappingURL=input-file-resolver.js.map