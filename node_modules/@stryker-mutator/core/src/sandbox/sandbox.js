"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sandbox = void 0;
const path = require("path");
const npmRunPath = require("npm-run-path");
const util_1 = require("@stryker-mutator/util");
const mkdirp = require("mkdirp");
const plugin_1 = require("@stryker-mutator/api/plugin");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const file_utils_1 = require("../utils/file-utils");
const di_1 = require("../di");
class Sandbox {
    constructor(options, log, temporaryDirectory, files, exec) {
        this.options = options;
        this.log = log;
        this.files = files;
        this.exec = exec;
        this.fileMap = new Map();
        this.workingDirectory = temporaryDirectory.createRandomDirectory('sandbox');
        this.log.debug('Creating a sandbox for files in %s', this.workingDirectory);
    }
    async initialize() {
        await this.fillSandbox();
        await this.runBuildCommand();
        await this.symlinkNodeModulesIfNeeded();
    }
    get sandboxFileNames() {
        return [...this.fileMap.entries()].map(([, to]) => to);
    }
    sandboxFileFor(fileName) {
        const sandboxFileName = this.fileMap.get(fileName);
        if (sandboxFileName === undefined) {
            throw new Error(`Cannot find sandbox file for ${fileName}`);
        }
        return sandboxFileName;
    }
    fillSandbox() {
        return rxjs_1.from(this.files)
            .pipe(operators_1.mergeMap((file) => this.fillFile(file), file_utils_1.MAX_CONCURRENT_FILE_IO), operators_1.toArray())
            .toPromise();
    }
    async runBuildCommand() {
        if (this.options.buildCommand) {
            const env = npmRunPath.env();
            this.log.info('Running build command "%s" in the sandbox at "%s".', this.options.buildCommand, this.workingDirectory);
            this.log.debug('(using PATH: %s)', env.PATH);
            await this.exec.command(this.options.buildCommand, { cwd: this.workingDirectory, env });
        }
    }
    async symlinkNodeModulesIfNeeded() {
        if (this.options.symlinkNodeModules) {
            // TODO: Change with this.options.basePath when we have it
            const basePath = process.cwd();
            const nodeModules = await file_utils_1.findNodeModules(basePath);
            if (nodeModules) {
                await file_utils_1.symlinkJunction(nodeModules, path.join(this.workingDirectory, 'node_modules')).catch((error) => {
                    if (error.code === 'EEXIST') {
                        this.log.warn(util_1.normalizeWhitespaces(`Could not symlink "${nodeModules}" in sandbox directory,
              it is already created in the sandbox. Please remove the node_modules from your sandbox files.
              Alternatively, set \`symlinkNodeModules\` to \`false\` to disable this warning.`));
                    }
                    else {
                        this.log.warn(`Unexpected error while trying to symlink "${nodeModules}" in sandbox directory.`, error);
                    }
                });
            }
            else {
                this.log.warn(`Could not find a node_modules folder to symlink into the sandbox directory. Search "${basePath}" and its parent directories`);
            }
        }
    }
    async fillFile(file) {
        const relativePath = path.relative(process.cwd(), file.name);
        const folderName = path.join(this.workingDirectory, path.dirname(relativePath));
        mkdirp.sync(folderName);
        const targetFileName = path.join(folderName, path.basename(relativePath));
        this.fileMap.set(file.name, targetFileName);
        await file_utils_1.writeFile(targetFileName, file.content);
    }
}
exports.Sandbox = Sandbox;
Sandbox.create = Object.assign(async (options, getLogger, files, tempDir, exec) => {
    const sandbox = new Sandbox(options, getLogger(Sandbox.name), tempDir, files, exec);
    await sandbox.initialize();
    return sandbox;
}, { inject: plugin_1.tokens(plugin_1.commonTokens.options, plugin_1.commonTokens.getLogger, di_1.coreTokens.files, di_1.coreTokens.temporaryDirectory, di_1.coreTokens.execa) });
//# sourceMappingURL=sandbox.js.map