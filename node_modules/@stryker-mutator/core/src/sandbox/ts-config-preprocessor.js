"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSConfigPreprocessor = void 0;
const path = require("path");
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
/**
 * A helper class that rewrites `references` and `extends` file paths if they end up falling outside of the sandbox.
 * @example
 * {
 *   "extends": "../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../model"
 *   }
 * }
 * becomes:
 * {
 *   "extends": "../../../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../../../model"
 *   }
 * }
 */
class TSConfigPreprocessor {
    constructor(log, options) {
        this.log = log;
        this.options = options;
        this.touched = [];
        this.fs = new Map();
    }
    async preprocess(input) {
        const tsconfigFile = path.resolve(this.options.tsconfigFile);
        if (input.find((file) => file.name === tsconfigFile)) {
            this.fs.clear();
            input.forEach((file) => {
                this.fs.set(file.name, file);
            });
            await this.rewriteTSConfigFile(tsconfigFile);
            return [...this.fs.values()];
        }
        else {
            return input;
        }
    }
    async rewriteTSConfigFile(tsconfigFileName) {
        if (!this.touched.includes(tsconfigFileName)) {
            this.touched.push(tsconfigFileName);
            const tsconfigFile = this.fs.get(tsconfigFileName);
            if (tsconfigFile) {
                this.log.debug('Rewriting file %s', tsconfigFile);
                const ts = await Promise.resolve().then(() => require('typescript'));
                const { config } = ts.parseConfigFileTextToJson(tsconfigFile.name, tsconfigFile.textContent);
                if (config) {
                    await this.rewriteExtends(config, tsconfigFileName);
                    await this.rewriteProjectReferences(config, tsconfigFileName);
                    this.fs.set(tsconfigFileName, new core_1.File(tsconfigFileName, JSON.stringify(config, null, 2)));
                }
            }
        }
    }
    async rewriteExtends(config, tsconfigFileName) {
        if (typeof config.extends === 'string') {
            const extendsFileName = path.resolve(path.dirname(tsconfigFileName), config.extends);
            const relativeToSandbox = path.relative(process.cwd(), extendsFileName);
            if (relativeToSandbox.startsWith('..')) {
                config.extends = this.join('..', '..', config.extends);
                return true;
            }
            else {
                await this.rewriteTSConfigFile(extendsFileName);
            }
        }
        return false;
    }
    async rewriteProjectReferences(config, originTSConfigFileName) {
        const ts = await Promise.resolve().then(() => require('typescript'));
        if (Array.isArray(config.references)) {
            for (const reference of config.references) {
                const referencePath = ts.resolveProjectReferencePath(reference);
                const referencedProjectFileName = path.resolve(path.dirname(originTSConfigFileName), referencePath);
                const relativeToProject = path.relative(process.cwd(), referencedProjectFileName);
                if (relativeToProject.startsWith('..')) {
                    reference.path = this.join('..', '..', referencePath);
                }
                else {
                    await this.rewriteTSConfigFile(referencedProjectFileName);
                }
            }
        }
    }
    join(...pathSegments) {
        return pathSegments.map((segment) => segment.replace(/\\/g, '/')).join('/');
    }
}
exports.TSConfigPreprocessor = TSConfigPreprocessor;
TSConfigPreprocessor.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
//# sourceMappingURL=ts-config-preprocessor.js.map