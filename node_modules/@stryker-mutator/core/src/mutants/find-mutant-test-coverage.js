"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMutantTestCoverage = void 0;
const plugin_1 = require("@stryker-mutator/api/plugin");
const di_1 = require("../di");
findMutantTestCoverage.inject = plugin_1.tokens(di_1.coreTokens.dryRunResult, di_1.coreTokens.mutants, di_1.coreTokens.reporter, plugin_1.commonTokens.logger);
function findMutantTestCoverage(dryRunResult, mutants, reporter, logger) {
    const mutantTestCoverage = mapToMutantTestCoverage(dryRunResult, mutants, logger);
    reporter.onAllMutantsMatchedWithTests(mutantTestCoverage.map(toMatchedMutant));
    return mutantTestCoverage;
}
exports.findMutantTestCoverage = findMutantTestCoverage;
function toMatchedMutant({ mutant, testFilter, coveredByTests, estimatedNetTime }) {
    return {
        fileName: mutant.fileName,
        id: mutant.id.toString(),
        mutatorName: mutant.mutatorName,
        replacement: mutant.replacement,
        runAllTests: !testFilter && coveredByTests,
        testFilter: testFilter,
        timeSpentScopedTests: estimatedNetTime,
    };
}
function mapToMutantTestCoverage(dryRunResult, mutants, logger) {
    var _a;
    const testsByMutantId = findTestsByMutant((_a = dryRunResult.mutantCoverage) === null || _a === void 0 ? void 0 : _a.perTest, dryRunResult.tests, logger);
    const timeSpentAllTests = calculateTotalTime(dryRunResult.tests);
    const mutantCoverage = mutants.map((mutant) => {
        if (mutant.ignoreReason !== undefined) {
            return {
                mutant,
                estimatedNetTime: 0,
                coveredByTests: false,
            };
        }
        else if (!dryRunResult.mutantCoverage || dryRunResult.mutantCoverage.static[mutant.id] > 0) {
            return {
                mutant,
                estimatedNetTime: timeSpentAllTests,
                testFilter: undefined,
                coveredByTests: true,
            };
        }
        else {
            const tests = testsByMutantId.get(mutant.id);
            if (tests && tests.size > 0) {
                return {
                    mutant,
                    estimatedNetTime: calculateTotalTime(tests),
                    testFilter: toTestIds(tests),
                    coveredByTests: true,
                };
            }
            else {
                return {
                    mutant,
                    estimatedNetTime: 0,
                    testFilter: undefined,
                    coveredByTests: false,
                };
            }
        }
    });
    return mutantCoverage;
}
function findTestsByMutant(coveragePerTest, allTests, logger) {
    const testsByMutantId = new Map();
    coveragePerTest &&
        Object.entries(coveragePerTest).forEach(([testId, mutantCoverage]) => {
            const test = allTests.find((test) => test.id === testId);
            if (!test) {
                logger.debug(`Found test with id "${testId}" in coverage data, but not in the test results of the dry run. Not taking coverage data for this test into account`);
                return;
            }
            Object.entries(mutantCoverage).forEach(([mutantIdAsString, count]) => {
                if (count) {
                    const mutantId = parseInt(mutantIdAsString, 10);
                    let tests = testsByMutantId.get(mutantId);
                    if (!tests) {
                        tests = new Set();
                        testsByMutantId.set(mutantId, tests);
                    }
                    tests.add(test);
                }
            });
        });
    return testsByMutantId;
}
function calculateTotalTime(testResults) {
    let total = 0;
    for (const test of testResults) {
        total += test.timeSpentMs;
    }
    return total;
}
function toTestIds(testResults) {
    const result = [];
    for (const test of testResults) {
        result.push(test.id);
    }
    return result;
}
//# sourceMappingURL=find-mutant-test-coverage.js.map