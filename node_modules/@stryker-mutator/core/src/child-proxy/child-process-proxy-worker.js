"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const core_1 = require("@stryker-mutator/api/core");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const di_1 = require("../di");
const logging_1 = require("../logging");
const object_utils_1 = require("../utils/object-utils");
const message_protocol_1 = require("./message-protocol");
class ChildProcessProxyWorker {
    constructor() {
        // Make sure to bind the methods in order to ensure the `this` pointer
        this.handleMessage = this.handleMessage.bind(this);
        process.on('message', this.handleMessage);
    }
    send(value) {
        if (process.send) {
            const str = object_utils_1.serialize(value, [core_1.File]);
            process.send(str);
        }
    }
    handleMessage(serializedMessage) {
        const message = object_utils_1.deserialize(serializedMessage, [core_1.File]);
        switch (message.kind) {
            case message_protocol_1.WorkerMessageKind.Init:
                this.handleInit(message);
                this.removeAnyAdditionalMessageListeners(this.handleMessage);
                break;
            case message_protocol_1.WorkerMessageKind.Call:
                this.handleCall(message);
                this.removeAnyAdditionalMessageListeners(this.handleMessage);
                break;
            case message_protocol_1.WorkerMessageKind.Dispose:
                const sendCompleted = () => {
                    this.send({ kind: message_protocol_1.ParentMessageKind.DisposeCompleted });
                };
                logging_1.LogConfigurator.shutdown().then(sendCompleted).catch(sendCompleted);
                break;
        }
    }
    handleInit(message) {
        logging_1.LogConfigurator.configureChildProcess(message.loggingContext);
        this.log = log4js_1.getLogger(ChildProcessProxyWorker.name);
        this.handlePromiseRejections();
        let injector = di_1.buildChildProcessInjector(message.options);
        const locals = message.additionalInjectableValues;
        for (const token in locals) {
            injector = injector.provideValue(token, locals[token]);
        }
        const RealSubjectClass = require(message.requirePath)[message.requireName];
        const workingDir = path.resolve(message.workingDirectory);
        if (process.cwd() !== workingDir) {
            this.log.debug(`Changing current working directory for this process to ${workingDir}`);
            process.chdir(workingDir);
        }
        this.realSubject = injector.injectClass(RealSubjectClass);
        this.send({ kind: message_protocol_1.ParentMessageKind.Initialized });
    }
    async handleCall(message) {
        try {
            const result = await this.doCall(message);
            this.send({
                correlationId: message.correlationId,
                kind: message_protocol_1.ParentMessageKind.Result,
                result,
            });
        }
        catch (err) {
            this.send({
                correlationId: message.correlationId,
                error: util_1.errorToString(err),
                kind: message_protocol_1.ParentMessageKind.Rejection,
            });
        }
    }
    doCall(message) {
        if (typeof this.realSubject[message.methodName] === 'function') {
            return this.realSubject[message.methodName](...message.args);
        }
        else {
            return this.realSubject[message.methodName];
        }
    }
    /**
     * Remove any addition message listeners that might me eavesdropping.
     * the @ngtools/webpack plugin listens to messages and throws an error whenever it could not handle a message
     * @see https://github.com/angular/angular-cli/blob/f776d3cf7982b64734c57fe4407434e9f4ec09f7/packages/%40ngtools/webpack/src/type_checker.ts#L79
     * @param exceptListener The listener that should remain
     */
    removeAnyAdditionalMessageListeners(exceptListener) {
        process.listeners('message').forEach((listener) => {
            if (listener !== exceptListener) {
                this.log.debug("Removing an additional message listener, we don't want eavesdropping on our inter-process communication: %s", listener.toString());
                process.removeListener('message', listener);
            }
        });
    }
    /**
     * During mutation testing, it's to be expected that promise rejections are not handled synchronously anymore (or not at all)
     * Let's handle those events so future versions of node don't crash
     * See issue 350: https://github.com/stryker-mutator/stryker/issues/350
     */
    handlePromiseRejections() {
        const unhandledRejections = [];
        process.on('unhandledRejection', (reason, promise) => {
            const unhandledPromiseId = unhandledRejections.push(promise);
            this.log.debug(`UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: ${unhandledPromiseId}): ${reason}`);
        });
        process.on('rejectionHandled', (promise) => {
            const unhandledPromiseId = unhandledRejections.indexOf(promise) + 1;
            this.log.debug(`PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: ${unhandledPromiseId})`);
        });
    }
}
exports.default = ChildProcessProxyWorker;
// Prevent side effects for merely requiring the file
// Only actually start the child worker when it is requested
if (process.argv.includes(message_protocol_1.autoStart)) {
    new ChildProcessProxyWorker();
}
//# sourceMappingURL=child-process-proxy-worker.js.map