"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mutatedLines = exports.originalLines = exports.isLineBreak = void 0;
function isLineBreak(ch) {
    // ES5 7.3:
    // The ECMAScript line terminator characters are listed in Table 3.
    //     Table 3: Line Terminator Characters
    //     Code Unit Value     Name                    Formal Name
    //     \u000A              Line Feed               <LF>
    //     \u000D              Carriage Return         <CR>
    //     \u2028              Line separator          <LS>
    //     \u2029              Paragraph separator     <PS>
    // Only the characters in Table 3 are treated as line terminators. Other new line or line
    // breaking characters are treated as white space but not as line terminators.
    return (ch === 10 /* LineFeed */ ||
        ch === 13 /* CarriageReturn */ ||
        ch === 8232 /* LineSeparator */ ||
        ch === 8233 /* ParagraphSeparator */);
}
exports.isLineBreak = isLineBreak;
function originalLines(originalText, mutant) {
    const [startIndex, endIndex] = getMutationLineIndexes(originalText, mutant);
    return originalText.substring(startIndex, endIndex);
}
exports.originalLines = originalLines;
function getMutationLineIndexes(originalText, mutant) {
    let startIndexLines = mutant.range[0];
    let endIndexLines = mutant.range[1];
    while (startIndexLines > 0 && !isLineBreak(originalText.charCodeAt(startIndexLines - 1))) {
        startIndexLines--;
    }
    while (endIndexLines < originalText.length && !isLineBreak(originalText.charCodeAt(endIndexLines))) {
        endIndexLines++;
    }
    return [startIndexLines, endIndexLines];
}
function mutatedLines(originalText, mutant) {
    const [startIndex, endIndex] = getMutationLineIndexes(originalText, mutant);
    return `${originalText.substring(startIndex, mutant.range[0])}${mutant.replacement}${originalText.substring(mutant.range[1], endIndex)}`;
}
exports.mutatedLines = mutatedLines;
//# sourceMappingURL=mutant-utils.js.map