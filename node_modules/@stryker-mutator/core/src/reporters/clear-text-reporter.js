"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const chalk = require("chalk");
const plugin_1 = require("@stryker-mutator/api/plugin");
const report_1 = require("@stryker-mutator/api/report");
const mutation_testing_metrics_1 = require("mutation-testing-metrics");
const typed_inject_1 = require("typed-inject");
const clear_text_score_table_1 = require("./clear-text-score-table");
class ClearTextReporter {
    constructor(log, options) {
        this.log = log;
        this.options = options;
        this.out = process.stdout;
        this.configConsoleColor();
    }
    writeLine(output) {
        this.out.write(`${output || ''}${os.EOL}`);
    }
    configConsoleColor() {
        if (!this.options.allowConsoleColors) {
            chalk.level = 0; // All colors disabled
        }
    }
    onAllMutantsTested(mutantResults) {
        this.writeLine();
        let totalTests = 0;
        // use these functions in order to preserve the 'this` pointer
        const logDebugFn = (input) => this.log.debug(input);
        const writeLineFn = (input) => this.writeLine(input);
        mutantResults.forEach((result) => {
            totalTests += result.nrOfTestsRan;
            switch (result.status) {
                case report_1.MutantStatus.Killed:
                case report_1.MutantStatus.TimedOut:
                case report_1.MutantStatus.RuntimeError:
                case report_1.MutantStatus.CompileError:
                    this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.Survived:
                case report_1.MutantStatus.NoCoverage:
                    this.logMutantResult(result, writeLineFn);
                    break;
            }
        });
        this.writeLine(`Ran ${(totalTests / mutantResults.length).toFixed(2)} tests per mutant on average.`);
    }
    logMutantResult(result, logImplementation) {
        logImplementation(`#${result.id}. [${report_1.MutantStatus[result.status]}] ${result.mutatorName}`);
        logImplementation(this.colorSourceFileAndLocation(result.fileName, result.location.start));
        result.originalLines.split('\n').forEach((line) => {
            logImplementation(chalk.red('-   ' + line));
        });
        result.mutatedLines.split('\n').forEach((line) => {
            logImplementation(chalk.green('+   ' + line));
        });
        logImplementation('');
        if (result.status === report_1.MutantStatus.Survived) {
            if (this.options.coverageAnalysis === 'perTest' && result.testFilter) {
                this.logExecutedTests(result, logImplementation);
            }
            else {
                logImplementation('Ran all tests for this mutant.');
            }
        }
        else if (result.status === report_1.MutantStatus.Killed) {
            logImplementation(`Killed by: ${result.killedBy}`);
        }
        else if (result.status === report_1.MutantStatus.RuntimeError || result.status === report_1.MutantStatus.CompileError) {
            logImplementation(`Error message: ${result.errorMessage}`);
        }
    }
    colorSourceFileAndLocation(fileName, position) {
        if (!this.options.clearTextReporter.allowColor) {
            return `${fileName}:${position.line}:${position.column}`;
        }
        return [chalk.cyan(fileName), chalk.yellow(`${position.line}`), chalk.yellow(`${position.column}`)].join(':');
    }
    logExecutedTests(result, logImplementation) {
        if (!this.options.clearTextReporter.logTests) {
            return;
        }
        if (result.nrOfTestsRan > 0) {
            const { maxTestsToLog } = this.options.clearTextReporter;
            if (maxTestsToLog > 0) {
                logImplementation('Tests ran:');
                for (let i = 0; i < maxTestsToLog; i++) {
                    if (i > result.testFilter.length - 1) {
                        break;
                    }
                    logImplementation(`    ${result.testFilter[i]}`);
                }
                const diff = result.testFilter.length - maxTestsToLog;
                if (diff > 0) {
                    const plural = diff === 1 ? '' : 's';
                    logImplementation(`  and ${diff} more test${plural}!`);
                }
                logImplementation('');
            }
        }
    }
    onMutationTestReportReady(report) {
        const metricsResult = mutation_testing_metrics_1.calculateMetrics(report.files);
        this.writeLine(new clear_text_score_table_1.default(metricsResult, this.options.thresholds).draw());
    }
}
exports.default = ClearTextReporter;
ClearTextReporter.inject = typed_inject_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
//# sourceMappingURL=clear-text-reporter.js.map