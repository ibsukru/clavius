"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutationTestReportHelper = void 0;
const path = require("path");
const plugin_1 = require("@stryker-mutator/api/plugin");
const report_1 = require("@stryker-mutator/api/report");
const util_1 = require("@stryker-mutator/util");
const mutation_testing_metrics_1 = require("mutation-testing-metrics");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const check_1 = require("@stryker-mutator/api/check");
const di_1 = require("../di");
const object_utils_1 = require("../utils/object-utils");
const mutant_utils_1 = require("../utils/mutant-utils");
/**
 * A helper class to convert and report mutants that survived or get killed
 */
class MutationTestReportHelper {
    constructor(reporter, options, inputFiles, log, dryRunResult) {
        this.reporter = reporter;
        this.options = options;
        this.inputFiles = inputFiles;
        this.log = log;
        this.dryRunResult = dryRunResult;
        this.testNamesById = new Map(this.dryRunResult.tests.map((test) => [test.id, test.name]));
    }
    reportCheckFailed(mutant, checkResult) {
        return this.reportOne(mutant, {
            status: this.checkStatusToResultStatus(checkResult.status),
            errorMessage: checkResult.reason,
        });
    }
    reportNoCoverage(mutant) {
        return this.reportOne(mutant, { status: report_1.MutantStatus.NoCoverage, testFilter: [] });
    }
    reportMutantIgnored(mutant) {
        return this.reportOne(mutant, { status: report_1.MutantStatus.Ignored, ignoreReason: mutant.ignoreReason });
    }
    reportMutantRunResult(mutantWithTestCoverage, result) {
        const { mutant, testFilter } = mutantWithTestCoverage;
        switch (result.status) {
            case test_runner_1.MutantRunStatus.Error:
                return this.reportOne(mutant, { status: report_1.MutantStatus.RuntimeError, errorMessage: result.errorMessage });
            case test_runner_1.MutantRunStatus.Killed:
                return this.reportOne(mutant, {
                    status: report_1.MutantStatus.Killed,
                    nrOfTestsRan: result.nrOfTests,
                    killedBy: this.testNamesById.get(result.killedBy),
                });
            case test_runner_1.MutantRunStatus.Timeout:
                return this.reportOne(mutant, { status: report_1.MutantStatus.TimedOut });
            case test_runner_1.MutantRunStatus.Survived:
                return this.reportOne(mutant, {
                    status: report_1.MutantStatus.Survived,
                    nrOfTestsRan: result.nrOfTests,
                    testFilter: testFilter ? this.dryRunResult.tests.filter((t) => testFilter.includes(t.id)).map((t) => t.name) : undefined,
                });
        }
    }
    reportOne(mutant, additionalFields) {
        const originalFileTextContent = this.inputFiles.filesToMutate.find((fileToMutate) => fileToMutate.name === mutant.fileName).textContent;
        const mutantResult = Object.assign({ id: mutant.id.toString(), location: mutant.location, mutatedLines: mutant_utils_1.mutatedLines(originalFileTextContent, mutant), mutatorName: mutant.mutatorName, originalLines: mutant_utils_1.originalLines(originalFileTextContent, mutant), range: mutant.range, replacement: mutant.replacement, fileName: mutant.fileName, nrOfTestsRan: 0 }, additionalFields);
        this.reporter.onMutantTested(mutantResult);
        return mutantResult;
    }
    checkStatusToResultStatus(status) {
        switch (status) {
            case check_1.CheckStatus.CompileError:
                return report_1.MutantStatus.CompileError;
        }
    }
    reportAll(results) {
        const report = this.mutationTestReport(results);
        this.reporter.onAllMutantsTested(results);
        this.reporter.onMutationTestReportReady(report);
        this.determineExitCode(report);
    }
    determineExitCode(report) {
        const { metrics } = mutation_testing_metrics_1.calculateMetrics(report.files);
        const breaking = this.options.thresholds.break;
        const formattedScore = metrics.mutationScore.toFixed(2);
        if (typeof breaking === 'number') {
            if (metrics.mutationScore < breaking) {
                this.log.error(`Final mutation score ${formattedScore} under breaking threshold ${breaking}, setting exit code to 1 (failure).`);
                this.log.info('(improve mutation score or set `thresholds.break = null` to prevent this error in the future)');
                object_utils_1.setExitCode(1);
            }
            else {
                this.log.info(`Final mutation score of ${formattedScore} is greater than or equal to break threshold ${breaking}`);
            }
        }
        else {
            this.log.debug("No breaking threshold configured. Won't fail the build no matter how low your mutation score is. Set `thresholds.break` to change this behavior.");
        }
    }
    mutationTestReport(results) {
        return {
            files: this.toFileResults(results),
            schemaVersion: '1.0',
            thresholds: this.options.thresholds,
        };
    }
    toFileResults(results) {
        const resultDictionary = Object.create(null);
        results.forEach((mutantResult) => {
            const fileResult = resultDictionary[mutantResult.fileName];
            if (fileResult) {
                fileResult.mutants.push(this.toMutantResult(mutantResult));
            }
            else {
                const sourceFile = this.inputFiles.files.find((file) => file.name === mutantResult.fileName);
                if (sourceFile) {
                    resultDictionary[mutantResult.fileName] = {
                        language: this.determineLanguage(sourceFile.name),
                        mutants: [this.toMutantResult(mutantResult)],
                        source: sourceFile.textContent,
                    };
                }
                else {
                    this.log.warn(util_1.normalizeWhitespaces(`File "${mutantResult.fileName}" not found
          in input files, but did receive mutant result for it. This shouldn't happen`));
                }
            }
        });
        return resultDictionary;
    }
    determineLanguage(name) {
        const ext = path.extname(name).toLowerCase();
        switch (ext) {
            case '.ts':
            case '.tsx':
                return 'typescript';
            case '.html':
            case '.vue':
                return 'html';
            default:
                return 'javascript';
        }
    }
    toMutantResult(mutantResult) {
        return {
            id: mutantResult.id,
            location: this.toLocation(mutantResult.location),
            mutatorName: mutantResult.mutatorName,
            replacement: mutantResult.replacement,
            status: this.toStatus(mutantResult.status),
            description: this.describe(mutantResult),
        };
    }
    toLocation(location) {
        return {
            end: this.toPosition(location.end),
            start: this.toPosition(location.start),
        };
    }
    toPosition(pos) {
        return {
            column: pos.column + 1,
            line: pos.line + 1,
        };
    }
    toStatus(status) {
        switch (status) {
            case report_1.MutantStatus.Killed:
                return "Killed" /* Killed */;
            case report_1.MutantStatus.NoCoverage:
                return "NoCoverage" /* NoCoverage */;
            case report_1.MutantStatus.RuntimeError:
                return "RuntimeError" /* RuntimeError */;
            case report_1.MutantStatus.Survived:
                return "Survived" /* Survived */;
            case report_1.MutantStatus.TimedOut:
                return "Timeout" /* Timeout */;
            case report_1.MutantStatus.CompileError:
                return "CompileError" /* CompileError */;
            case report_1.MutantStatus.Ignored:
                return "Ignored" /* Ignored */;
            default:
                this.logUnsupportedMutantStatus(status);
                return "RuntimeError" /* RuntimeError */;
        }
    }
    describe(mutantResult) {
        switch (mutantResult.status) {
            case report_1.MutantStatus.Ignored:
                return `Ignore reason: ${mutantResult.ignoreReason}`;
            case report_1.MutantStatus.Killed:
                return `Killed by: ${mutantResult.killedBy}`;
            case report_1.MutantStatus.CompileError:
            case report_1.MutantStatus.RuntimeError:
                return `Error message: ${mutantResult.errorMessage}`;
            default:
                return undefined;
        }
    }
    logUnsupportedMutantStatus(status) {
        this.log.warn('Unable to convert "%s" to a MutantStatus', status);
    }
}
exports.MutationTestReportHelper = MutationTestReportHelper;
MutationTestReportHelper.inject = plugin_1.tokens(di_1.coreTokens.reporter, plugin_1.commonTokens.options, di_1.coreTokens.inputFiles, plugin_1.commonTokens.logger, di_1.coreTokens.dryRunResult);
//# sourceMappingURL=mutation-test-report-helper.js.map