"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckerWorker = void 0;
const tslib_1 = require("tslib");
const check_1 = require("@stryker-mutator/api/check");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
class CheckerWorker {
    constructor(options, injector) {
        this.innerCheckers = [];
        const pluginCreator = injector.injectFunction(di_1.PluginCreator.createFactory(plugin_1.PluginKind.Checker));
        this.innerCheckers = options.checkers.map((name) => ({ name, checker: pluginCreator.create(name) }));
    }
    async init() {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__asyncValues(this.innerCheckers), _c; _c = await _b.next(), !_c.done;) {
                const { name, checker } = _c.value;
                try {
                    await checker.init();
                }
                catch (error) {
                    throw new util_1.StrykerError(`An error occurred during initialization of the "${name}" checker`, error);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    async check(mutant) {
        var e_2, _a;
        try {
            for (var _b = tslib_1.__asyncValues(this.innerCheckers), _c; _c = await _b.next(), !_c.done;) {
                const { checker } = _c.value;
                const result = await checker.check(mutant);
                if (result.status !== check_1.CheckStatus.Passed) {
                    return result;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return { status: check_1.CheckStatus.Passed };
    }
}
exports.CheckerWorker = CheckerWorker;
CheckerWorker.inject = plugin_1.tokens(plugin_1.commonTokens.options, plugin_1.commonTokens.injector);
//# sourceMappingURL=checker-worker.js.map