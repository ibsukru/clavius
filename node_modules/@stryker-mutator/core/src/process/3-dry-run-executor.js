"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DryRunExecutor = void 0;
const os_1 = require("os");
const plugin_1 = require("@stryker-mutator/api/plugin");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const operators_1 = require("rxjs/operators");
const di_1 = require("../di");
const test_runner_2 = require("../test-runner");
const mutation_test_report_helper_1 = require("../reporters/mutation-test-report-helper");
const errors_1 = require("../errors");
const mutants_1 = require("../mutants");
const pool_1 = require("../concurrent/pool");
// The initial run might take a while.
// For example: angular-bootstrap takes up to 45 seconds.
// Lets take 5 minutes just to be sure
const INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;
const INITIAL_TEST_RUN_MARKER = 'Initial test run';
function isFailedTest(testResult) {
    return testResult.status === test_runner_1.TestStatus.Failed;
}
class DryRunExecutor {
    constructor(injector, log, options, timer, concurrencyTokenProvider) {
        this.injector = injector;
        this.log = log;
        this.options = options;
        this.timer = timer;
        this.concurrencyTokenProvider = concurrencyTokenProvider;
    }
    async execute() {
        const testRunnerInjector = this.injector
            .provideFactory(di_1.coreTokens.testRunnerFactory, test_runner_2.createTestRunnerFactory)
            .provideValue(di_1.coreTokens.testRunnerConcurrencyTokens, this.concurrencyTokenProvider.testRunnerToken$)
            .provideFactory(di_1.coreTokens.testRunnerPool, pool_1.createTestRunnerPool);
        const testRunnerPool = testRunnerInjector.resolve(di_1.coreTokens.testRunnerPool);
        const testRunner = await testRunnerPool.worker$.pipe(operators_1.first()).toPromise();
        const { dryRunResult, timing } = await this.timeDryRun(testRunner);
        this.logInitialTestRunSucceeded(dryRunResult.tests, timing);
        if (!dryRunResult.tests.length) {
            throw new errors_1.ConfigError('No tests were executed. Stryker will exit prematurely. Please check your configuration.');
        }
        return testRunnerInjector
            .provideValue(di_1.coreTokens.timeOverheadMS, timing.overhead)
            .provideValue(di_1.coreTokens.dryRunResult, dryRunResult)
            .provideClass(di_1.coreTokens.mutationTestReportHelper, mutation_test_report_helper_1.MutationTestReportHelper)
            .provideFactory(di_1.coreTokens.mutantsWithTestCoverage, mutants_1.findMutantTestCoverage);
    }
    validateResultCompleted(runResult) {
        switch (runResult.status) {
            case test_runner_1.DryRunStatus.Complete:
                const failedTests = runResult.tests.filter(isFailedTest);
                if (failedTests.length) {
                    this.logFailedTestsInInitialRun(failedTests);
                    throw new errors_1.ConfigError('There were failed tests in the initial test run.');
                }
                return;
            case test_runner_1.DryRunStatus.Error:
                this.logErrorsInInitialRun(runResult);
                break;
            case test_runner_1.DryRunStatus.Timeout:
                this.logTimeoutInitialRun();
                break;
        }
        throw new Error('Something went wrong in the initial test run');
    }
    async timeDryRun(testRunner) {
        this.timer.mark(INITIAL_TEST_RUN_MARKER);
        this.log.info('Starting initial test run. This may take a while.');
        const dryRunResult = await testRunner.dryRun({ timeout: INITIAL_RUN_TIMEOUT, coverageAnalysis: this.options.coverageAnalysis });
        const grossTimeMS = this.timer.elapsedMs(INITIAL_TEST_RUN_MARKER);
        const humanReadableTimeElapsed = this.timer.humanReadableElapsed(INITIAL_TEST_RUN_MARKER);
        this.validateResultCompleted(dryRunResult);
        const timing = this.calculateTiming(grossTimeMS, humanReadableTimeElapsed, dryRunResult.tests);
        return { dryRunResult, timing };
    }
    logInitialTestRunSucceeded(tests, timing) {
        this.log.info('Initial test run succeeded. Ran %s tests in %s (net %s ms, overhead %s ms).', tests.length, timing.humanReadableTimeElapsed, timing.net, timing.overhead);
    }
    /**
     * Calculates the timing variables for the test run.
     * grossTime = NetTime + overheadTime
     *
     * The overhead time is used to calculate exact timeout values during mutation testing.
     * See timeoutMS setting in README for more information on this calculation
     */
    calculateTiming(grossTimeMS, humanReadableTimeElapsed, tests) {
        const netTimeMS = tests.reduce((total, test) => total + test.timeSpentMs, 0);
        const overheadTimeMS = grossTimeMS - netTimeMS;
        return {
            net: netTimeMS,
            overhead: overheadTimeMS < 0 ? 0 : overheadTimeMS,
            humanReadableTimeElapsed,
        };
    }
    logFailedTestsInInitialRun(failedTests) {
        let message = 'One or more tests failed in the initial test run:';
        failedTests.forEach((test) => {
            message += `${os_1.EOL}\t${test.name}`;
            message += `${os_1.EOL}\t\t${test.failureMessage}`;
        });
        this.log.error(message);
    }
    logErrorsInInitialRun(runResult) {
        let message = `One or more tests resulted in an error:${os_1.EOL}\t${runResult.errorMessage}`;
        this.log.error(message);
    }
    logTimeoutInitialRun() {
        this.log.error('Initial test run timed out!');
    }
}
exports.DryRunExecutor = DryRunExecutor;
DryRunExecutor.inject = plugin_1.tokens(plugin_1.commonTokens.injector, plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.timer, di_1.coreTokens.concurrencyTokenProvider);
//# sourceMappingURL=3-dry-run-executor.js.map