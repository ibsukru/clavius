"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutationTestExecutor = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const plugin_1 = require("@stryker-mutator/api/plugin");
const check_1 = require("@stryker-mutator/api/check");
const di_1 = require("../di");
class MutationTestExecutor {
    constructor(options, reporter, checkerPool, testRunnerPool, timeOverheadMS, matchedMutants, mutationTestReportHelper, sandbox, log, timer, concurrencyTokenProvider) {
        this.options = options;
        this.reporter = reporter;
        this.checkerPool = checkerPool;
        this.testRunnerPool = testRunnerPool;
        this.timeOverheadMS = timeOverheadMS;
        this.matchedMutants = matchedMutants;
        this.mutationTestReportHelper = mutationTestReportHelper;
        this.sandbox = sandbox;
        this.log = log;
        this.timer = timer;
        this.concurrencyTokenProvider = concurrencyTokenProvider;
    }
    async execute() {
        const { ignoredResult$, notIgnoredMutant$ } = this.executeIgnore(rxjs_1.from(this.matchedMutants));
        const { passedMutant$, checkResult$ } = this.executeCheck(rxjs_1.from(notIgnoredMutant$));
        const { coveredMutant$, noCoverageResult$ } = this.executeNoCoverage(passedMutant$);
        const testRunnerResult$ = this.executeRunInTestRunner(coveredMutant$);
        const results = await rxjs_1.merge(testRunnerResult$, checkResult$, noCoverageResult$, ignoredResult$).pipe(operators_1.toArray()).toPromise();
        this.mutationTestReportHelper.reportAll(results);
        await this.reporter.wrapUp();
        this.logDone();
        return results;
    }
    executeIgnore(input$) {
        const [notIgnoredMutant$, ignoredMutant$] = rxjs_1.partition(input$.pipe(operators_1.shareReplay()), ({ mutant }) => mutant.ignoreReason === undefined);
        const ignoredResult$ = ignoredMutant$.pipe(operators_1.map(({ mutant }) => this.mutationTestReportHelper.reportMutantIgnored(mutant)));
        return { ignoredResult$, notIgnoredMutant$ };
    }
    executeNoCoverage(input$) {
        const [coveredMutant$, noCoverageMatchedMutant$] = rxjs_1.partition(input$.pipe(operators_1.shareReplay()), (matchedMutant) => matchedMutant.coveredByTests);
        const noCoverageResult$ = noCoverageMatchedMutant$.pipe(operators_1.map(({ mutant }) => this.mutationTestReportHelper.reportNoCoverage(mutant)));
        return { noCoverageResult$, coveredMutant$ };
    }
    executeCheck(input$) {
        const checkTask$ = rxjs_1.zip(input$, this.checkerPool.worker$).pipe(operators_1.flatMap(async ([matchedMutant, checker]) => {
            const checkResult = await checker.check(matchedMutant.mutant);
            this.checkerPool.recycle(checker);
            return {
                checkResult,
                matchedMutant,
            };
        }), 
        // Dispose when all checks are completed.
        // This will allow resources to be freed up and more test runners to be spined up.
        operators_1.tap({
            complete: () => {
                this.checkerPool.dispose();
                this.concurrencyTokenProvider.freeCheckers();
            },
        }));
        const [passedCheckResult$, failedCheckResult$] = rxjs_1.partition(checkTask$.pipe(operators_1.shareReplay()), ({ checkResult }) => checkResult.status === check_1.CheckStatus.Passed);
        const checkResult$ = failedCheckResult$.pipe(operators_1.map((failedMutant) => this.mutationTestReportHelper.reportCheckFailed(failedMutant.matchedMutant.mutant, failedMutant.checkResult)));
        const passedMutant$ = passedCheckResult$.pipe(operators_1.map(({ matchedMutant }) => matchedMutant));
        return { checkResult$, passedMutant$ };
    }
    executeRunInTestRunner(input$) {
        return rxjs_1.zip(this.testRunnerPool.worker$, input$).pipe(operators_1.flatMap(async ([testRunner, matchedMutant]) => {
            const mutantRunOptions = this.createMutantRunOptions(matchedMutant);
            const result = await testRunner.mutantRun(mutantRunOptions);
            this.testRunnerPool.recycle(testRunner);
            return this.mutationTestReportHelper.reportMutantRunResult(matchedMutant, result);
        }));
    }
    createMutantRunOptions(mutant) {
        const timeout = this.options.timeoutFactor * mutant.estimatedNetTime + this.options.timeoutMS + this.timeOverheadMS;
        return {
            activeMutant: mutant.mutant,
            timeout: timeout,
            testFilter: mutant.testFilter,
            sandboxFileName: this.sandbox.sandboxFileFor(mutant.mutant.fileName),
        };
    }
    logDone() {
        this.log.info('Done in %s.', this.timer.humanReadableElapsed());
    }
}
exports.MutationTestExecutor = MutationTestExecutor;
MutationTestExecutor.inject = plugin_1.tokens(plugin_1.commonTokens.options, di_1.coreTokens.reporter, di_1.coreTokens.checkerPool, di_1.coreTokens.testRunnerPool, di_1.coreTokens.timeOverheadMS, di_1.coreTokens.mutantsWithTestCoverage, di_1.coreTokens.mutationTestReportHelper, di_1.coreTokens.sandbox, plugin_1.commonTokens.logger, di_1.coreTokens.timer, di_1.coreTokens.concurrencyTokenProvider);
//# sourceMappingURL=4-mutation-test-executor.js.map