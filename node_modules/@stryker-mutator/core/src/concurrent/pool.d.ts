import { Observable } from 'rxjs';
import { Disposable } from 'typed-inject';
import { TestRunner } from '@stryker-mutator/api/test-runner';
import { Checker } from '@stryker-mutator/api/check';
export interface Worker {
    init?(): Promise<unknown>;
    dispose?(): Promise<unknown>;
}
export declare function createTestRunnerPool(factory: () => TestRunner, concurrencyToken$: Observable<number>): Pool<TestRunner>;
export declare namespace createTestRunnerPool {
    var inject: ["testRunnerFactory", "testRunnerConcurrencyTokens"];
}
export declare function createCheckerPool(factory: () => Checker, concurrencyToken$: Observable<number>): Pool<Checker>;
export declare namespace createCheckerPool {
    var inject: ["checkerFactory", "checkerConcurrencyTokens"];
}
/**
 * Represents a pool of workers.
 * Creates as many workers as the concurrency tokens allow.
 * Also takes care of the initialing of the workers (with `init()`)
 * Re-emit a worker via `recycle`.
 *
 * Please recycle! ðŸš®
 */
export declare class Pool<T extends Worker> implements Disposable {
    private readonly recycleBin;
    private readonly allWorkers;
    readonly worker$: Observable<T>;
    private readonly createdWorker$;
    constructor(factory: () => T, concurrencyToken$: Observable<number>);
    /**
     * Returns a promise that resolves if all concurrency tokens have resulted in initialized workers.
     * This is optional, workers will get initialized either way.
     */
    init(): Promise<void>;
    /**
     * Recycles a worker so its re-emitted from the `worker$` observable.
     * @param worker The worker to recycle
     */
    recycle(worker: T): void;
    private isDisposed;
    /**
     * Dispose the pool
     */
    dispose(): Promise<void>;
}
//# sourceMappingURL=pool.d.ts.map