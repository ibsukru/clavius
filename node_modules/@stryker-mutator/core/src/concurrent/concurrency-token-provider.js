"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrencyTokenProvider = void 0;
const os = require("os");
const rxjs_1 = require("rxjs");
const typed_inject_1 = require("typed-inject");
const plugin_1 = require("@stryker-mutator/api/plugin");
class ConcurrencyTokenProvider {
    constructor(options, log) {
        var _a;
        this.log = log;
        this.testRunnerTokenSubject = new rxjs_1.ReplaySubject();
        this.count = 0;
        const cpuCount = os.cpus().length;
        const concurrency = (_a = options.concurrency) !== null && _a !== void 0 ? _a : (cpuCount > 4 ? cpuCount - 1 : cpuCount);
        if (options.checkers.length > 0) {
            this.concurrencyCheckers = Math.max(Math.ceil(concurrency / 2), 1);
            this.checkerToken$ = rxjs_1.range(this.concurrencyCheckers);
            this.concurrencyTestRunners = Math.max(Math.floor(concurrency / 2), 1);
            log.info('Creating %s checker process(es) and %s test runner process(es).', this.concurrencyCheckers, this.concurrencyTestRunners);
        }
        else {
            this.concurrencyCheckers = 0;
            this.checkerToken$ = rxjs_1.range(1); // at least one checker, the `CheckerFacade` will not create worker process.
            this.concurrencyTestRunners = concurrency;
            log.info('Creating %s test runner process(es).', this.concurrencyTestRunners);
        }
        Array.from({ length: this.concurrencyTestRunners }).forEach(() => this.testRunnerTokenSubject.next(this.tick()));
    }
    get testRunnerToken$() {
        return this.testRunnerTokenSubject;
    }
    freeCheckers() {
        if (this.concurrencyCheckers > 0) {
            this.log.debug('Checking done, creating %s additional test runner process(es)', this.concurrencyCheckers);
            for (let i = 0; i < this.concurrencyCheckers; i++) {
                this.testRunnerTokenSubject.next(this.tick());
            }
            this.testRunnerTokenSubject.complete();
        }
    }
    tick() {
        return this.count++;
    }
    dispose() {
        this.testRunnerTokenSubject.complete();
    }
}
exports.ConcurrencyTokenProvider = ConcurrencyTokenProvider;
ConcurrencyTokenProvider.inject = typed_inject_1.tokens(plugin_1.commonTokens.options, plugin_1.commonTokens.logger);
//# sourceMappingURL=concurrency-token-provider.js.map