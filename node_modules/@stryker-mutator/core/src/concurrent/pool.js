"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = exports.createCheckerPool = exports.createTestRunnerPool = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const util_1 = require("@stryker-mutator/util");
const typed_inject_1 = require("typed-inject");
const di_1 = require("../di");
const MAX_CONCURRENT_INIT = 2;
createTestRunnerPool.inject = typed_inject_1.tokens(di_1.coreTokens.testRunnerFactory, di_1.coreTokens.testRunnerConcurrencyTokens);
function createTestRunnerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createTestRunnerPool = createTestRunnerPool;
createCheckerPool.inject = typed_inject_1.tokens(di_1.coreTokens.checkerFactory, di_1.coreTokens.checkerConcurrencyTokens);
function createCheckerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createCheckerPool = createCheckerPool;
/**
 * Represents a pool of workers.
 * Creates as many workers as the concurrency tokens allow.
 * Also takes care of the initialing of the workers (with `init()`)
 * Re-emit a worker via `recycle`.
 *
 * Please recycle! ðŸš®
 */
class Pool {
    constructor(factory, concurrencyToken$) {
        this.recycleBin = new rxjs_1.Subject();
        this.allWorkers = [];
        this.isDisposed = false;
        this.createdWorker$ = concurrencyToken$.pipe(operators_1.flatMap(async () => {
            var _a;
            if (this.isDisposed) {
                return null;
            }
            else {
                const worker = factory();
                this.allWorkers.push(worker);
                await ((_a = worker.init) === null || _a === void 0 ? void 0 : _a.call(worker));
                return worker;
            }
        }, MAX_CONCURRENT_INIT), operators_1.filter(util_1.notEmpty), 
        // We use share replay here. This way the dry run can use a test runner that is later reused during mutation testing
        // https://www.learnrxjs.io/learn-rxjs/operators/multicasting/sharereplay
        operators_1.shareReplay());
        this.worker$ = rxjs_1.merge(this.recycleBin, this.createdWorker$);
    }
    /**
     * Returns a promise that resolves if all concurrency tokens have resulted in initialized workers.
     * This is optional, workers will get initialized either way.
     */
    async init() {
        await this.createdWorker$.toPromise();
    }
    /**
     * Recycles a worker so its re-emitted from the `worker$` observable.
     * @param worker The worker to recycle
     */
    recycle(worker) {
        this.recycleBin.next(worker);
    }
    /**
     * Dispose the pool
     */
    async dispose() {
        this.isDisposed = true;
        this.recycleBin.complete();
        await Promise.all(this.allWorkers.map((worker) => { var _a; return (_a = worker.dispose) === null || _a === void 0 ? void 0 : _a.call(worker); }));
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map