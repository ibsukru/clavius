"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const immutable_1 = require("../../src/immutable");
describe(immutable_1.deepFreeze.name, () => {
    it('should not change the input object', () => {
        const input = {};
        immutable_1.deepFreeze(input);
        chai_1.expect(input).not.frozen;
    });
    it('should freeze objects', () => {
        const input = { foo: 'bar', baz: 42 };
        const output = immutable_1.deepFreeze(input);
        chai_1.expect(output).frozen;
        chai_1.expect(output).deep.eq(input);
        chai_1.expect(output).not.eq(input);
    });
    it('should work for `null` and `undefined`', () => {
        chai_1.expect(immutable_1.deepFreeze(null)).eq(null);
        chai_1.expect(immutable_1.deepFreeze(undefined)).eq(undefined);
    });
    it('should work for primitives', () => {
        const s = Symbol();
        chai_1.expect(immutable_1.deepFreeze(42)).eq(42);
        chai_1.expect(immutable_1.deepFreeze('foo')).eq('foo');
        chai_1.expect(immutable_1.deepFreeze(s)).eq(s);
        chai_1.expect(immutable_1.deepFreeze(true)).eq(true);
    });
    it('should deeply freeze objects', () => {
        const input = {
            foo: {
                bar: {
                    baz: 'qux',
                },
            },
        };
        const output = immutable_1.deepFreeze(input);
        chai_1.expect(output).deep.eq(input);
        chai_1.expect(output).frozen;
        chai_1.expect(output.foo).frozen;
        chai_1.expect(output.foo.bar).frozen;
    });
    it('should work for Arrays', () => {
        const one = {
            foo: 'bar',
        };
        const two = {
            baz: 42,
        };
        const input = [one, two];
        const output = immutable_1.deepFreeze(input);
        chai_1.expect(output).frozen;
        chai_1.expect(output).instanceOf(Array);
        chai_1.expect(output).lengthOf(2);
        chai_1.expect(output).deep.eq(input);
        chai_1.expect(input).not.frozen;
        chai_1.expect(one).not.frozen;
        chai_1.expect(two).not.frozen;
        for (const v of output) {
            chai_1.expect(v).frozen;
        }
    });
    it('should work for Maps', () => {
        const key = {
            foo: 'bar',
        };
        const value = {
            baz: 42,
        };
        const input = new Map([[key, value]]);
        const output = immutable_1.deepFreeze(input);
        chai_1.expect(output).frozen;
        chai_1.expect(output).lengthOf(1);
        chai_1.expect(output).deep.eq(input);
        chai_1.expect(input).not.frozen;
        chai_1.expect(key).not.frozen;
        chai_1.expect(value).not.frozen;
        for (const [k, v] of output.entries()) {
            chai_1.expect(k).frozen;
            chai_1.expect(v).frozen;
        }
    });
    it('should work for Sets', () => {
        const value = {
            foo: 'bar',
        };
        const input = new Set([value]);
        const output = immutable_1.deepFreeze(input);
        chai_1.expect(output).frozen;
        chai_1.expect(output).lengthOf(1);
        chai_1.expect(output).deep.eq(input);
        chai_1.expect(input).not.frozen;
        chai_1.expect(value).not.frozen;
        for (const v of output.values()) {
            chai_1.expect(v).frozen;
        }
    });
});
//# sourceMappingURL=immutable.spec.js.map