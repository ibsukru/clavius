"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const src_1 = require("../../src");
describe('stringUtils', () => {
    describe(src_1.normalizeWhitespaces.name, () => {
        it('should not change strings without consecutive whitespaces', () => {
            chai_1.expect(src_1.normalizeWhitespaces('foo bar baz')).eq('foo bar baz');
        });
        it('should normalize a string with multiple consecutive spaces', () => {
            chai_1.expect(src_1.normalizeWhitespaces('foo  bar   baz')).eq('foo bar baz');
        });
        it('should normalize a string with multiple consecutive spaces, tabs and new lines', () => {
            chai_1.expect(src_1.normalizeWhitespaces('foo \t \n bar\n\tbaz')).eq('foo bar baz');
        });
    });
    describe(src_1.PropertyPathBuilder.name, () => {
        it('should be able to point to a path', () => {
            chai_1.expect(src_1.PropertyPathBuilder.create().prop('bar').prop('baz').build()).eq('bar.baz');
        });
    });
    describe(src_1.propertyPath.name, () => {
        it('should be able to point to a path', () => {
            chai_1.expect(src_1.propertyPath('bar')).eq('bar');
        });
    });
    describe(src_1.escapeRegExpLiteral.name, () => {
        it('should return input if no special chars are found', () => {
            chai_1.expect(src_1.escapeRegExpLiteral('something normal')).eq('something normal');
        });
        for (const letter of '.*+-?^${}()|[]\\/') {
            it(`should escape "${letter}"`, () => {
                chai_1.expect(src_1.escapeRegExpLiteral(letter)).eq(`\\${letter}`);
            });
        }
    });
    describe(src_1.escapeRegExp.name, () => {
        it('should return input if no special chars are found', () => {
            chai_1.expect(src_1.escapeRegExp('something normal')).eq('something normal');
        });
        it("should not escape `/` (that's only needed for regex literals)", () => {
            chai_1.expect(src_1.escapeRegExp('n/a')).eq('n/a');
        });
        for (const letter of '.*+-?^${}()|[]\\') {
            it(`should escape "${letter}"`, () => {
                chai_1.expect(src_1.escapeRegExp(letter)).eq(`\\${letter}`);
            });
        }
    });
});
//# sourceMappingURL=string-utils.spec.js.map