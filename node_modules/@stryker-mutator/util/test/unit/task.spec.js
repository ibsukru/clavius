"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const src_1 = require("../../src");
describe(src_1.Task.name, () => {
    it('should give access to underlying promise', () => {
        const sut = new src_1.Task();
        chai_1.expect(sut.promise).instanceOf(Promise);
        sut.resolve();
    });
    it('should be able to resolve the underlying promise', async () => {
        const sut = new src_1.Task();
        sut.resolve('resolved');
        const result = await sut.promise;
        chai_1.expect(result).eq('resolved');
    });
    it('should be able to reject the underlying promise', async () => {
        const sut = new src_1.Task();
        const expectedError = new Error('expected error');
        sut.reject(expectedError);
        await chai_1.expect(sut.promise).rejectedWith(expectedError);
    });
    it('should be able to know if it isCompleted', () => {
        const sut = new src_1.Task();
        chai_1.expect(sut.isCompleted).false;
        sut.resolve();
        chai_1.expect(sut.isCompleted).true;
    });
});
describe(src_1.ExpirableTask.name, () => {
    describe('instance', () => {
        it('should timeout after set period', async () => {
            const task = new src_1.ExpirableTask(0);
            const result = await task.promise;
            chai_1.expect(result).eq(src_1.ExpirableTask.TimeoutExpired);
        });
        it('should be able to resolve within time', async () => {
            const task = new src_1.ExpirableTask(0);
            task.resolve('in time');
            const result = await task.promise;
            chai_1.expect(result).eq('in time');
        });
        it('should be able to reject within time', async () => {
            const task = new src_1.ExpirableTask(0);
            const expectedError = new Error('expected error');
            task.reject(expectedError);
            await chai_1.expect(task.promise).rejectedWith(expectedError);
        });
    });
    describe('timeout', () => {
        it('should timeout a promise after a set period', async () => {
            const task = new src_1.Task();
            const actual = await src_1.ExpirableTask.timeout(task.promise, 0);
            chai_1.expect(actual).eq(src_1.ExpirableTask.TimeoutExpired);
            task.resolve(undefined);
        });
        it('should remove any nodejs timers when promise resolves', async () => {
            // Arrange
            const expectedTimer = 234;
            const setTimeoutStub = sinon.stub(global, 'setTimeout');
            const clearTimeoutStub = sinon.stub(global, 'clearTimeout');
            setTimeoutStub.returns(expectedTimer);
            const expectedResult = 'expectedResult';
            const p = Promise.resolve(expectedResult);
            const delay = 10;
            // Act
            const result = await src_1.ExpirableTask.timeout(p, delay);
            // Assert
            chai_1.expect(result).eq(expectedResult);
            chai_1.expect(clearTimeoutStub).calledWith(expectedTimer);
            chai_1.expect(setTimeoutStub).calledWith(sinon.match.func, delay);
        });
    });
});
//# sourceMappingURL=task.spec.js.map