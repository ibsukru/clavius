"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMetrics = void 0;
const helpers_1 = require("./helpers");
const helpers_2 = require("./helpers");
const DEFAULT_SCORE = NaN;
const ROOT_NAME = 'All files';
/**
 * Calculates the metrics inside of a mutation testing report
 * @param files The files inside the mutation testing report
 * @returns A MetricsResult containing the metrics for the entire report. See `childResults`
 */
function calculateMetrics(files) {
    const normalizedFiles = helpers_1.normalizeFileNames(files);
    return calculateDirectoryMetrics(normalizedFiles, ROOT_NAME);
}
exports.calculateMetrics = calculateMetrics;
function calculateDirectoryMetrics(files, name) {
    const metrics = countMetrics(helpers_1.flatMap(Object.values(files), (file) => file.mutants));
    const childResults = toChildModels(files);
    return {
        name,
        childResults,
        metrics,
    };
}
function calculateFileMetrics(fileName, file) {
    return {
        file,
        name: fileName,
        childResults: [],
        metrics: countMetrics(file.mutants),
    };
}
function toChildModels(files) {
    const filesByDirectory = helpers_2.groupBy(Object.entries(files), (namedFile) => namedFile[0].split('/')[0]);
    return Object.keys(filesByDirectory)
        .map((directoryName) => {
        if (filesByDirectory[directoryName].length > 1 || filesByDirectory[directoryName][0][0] !== directoryName) {
            const directoryFiles = {};
            filesByDirectory[directoryName].forEach((file) => (directoryFiles[file[0].substr(directoryName.length + 1)] = file[1]));
            return calculateDirectoryMetrics(directoryFiles, directoryName);
        }
        else {
            const fileName = filesByDirectory[directoryName][0][0];
            const file = filesByDirectory[directoryName][0][1];
            return calculateFileMetrics(fileName, file);
        }
    })
        .sort(helpers_1.compareNames);
}
function countMetrics(mutants) {
    const count = (status) => mutants.filter((_) => _.status === status).length;
    const killed = count("Killed" /* Killed */);
    const timeout = count("Timeout" /* Timeout */);
    const survived = count("Survived" /* Survived */);
    const noCoverage = count("NoCoverage" /* NoCoverage */);
    const runtimeErrors = count("RuntimeError" /* RuntimeError */);
    const compileErrors = count("CompileError" /* CompileError */);
    const ignored = count("Ignored" /* Ignored */);
    const totalDetected = timeout + killed;
    const totalUndetected = survived + noCoverage;
    const totalCovered = totalDetected + survived;
    const totalValid = totalUndetected + totalDetected;
    const totalInvalid = runtimeErrors + compileErrors;
    return {
        killed,
        timeout,
        survived,
        noCoverage,
        runtimeErrors,
        compileErrors,
        ignored,
        totalDetected,
        totalUndetected,
        totalCovered,
        totalValid,
        totalInvalid,
        mutationScore: totalValid > 0 ? (totalDetected / totalValid) * 100 : DEFAULT_SCORE,
        totalMutants: totalValid + totalInvalid + ignored,
        mutationScoreBasedOnCoveredCode: totalValid > 0 ? (totalDetected / totalCovered) * 100 || 0 : DEFAULT_SCORE,
    };
}
//# sourceMappingURL=calculateMetrics.js.map